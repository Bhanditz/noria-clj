1. Rational за новой мета-библиотекой

Все плохо.
Мы все хотим писать UI!
Под все платформы и на всех языках.
Писать UI сложно! Есть много платформ: Android, iOS, Windows, macOS, linux, Browser etc.
Для каждой из них есть UI-фреймворк: Cocoa, Cocoa Touch, WPF, Swing, Gtk, DOM etc.
Каждый из них реализует и промоутит свою архитектуру: MVC, MVP, MVVM, MVC (Apple) etc.
Каждый представляет объектно-ориентированный API.
Написание UI сводится к обработки событий (от пользователя, внешнего мира, сервера, файловой системы и тд).
т.е. от нас требуется описать изменение состояния графа объектов под действием этих событий. Но чтобы привести состояние в новое, требуется знать,
из какого! Это делает написание современного динамического интерфейса безумно сложным и бажным.
При обработки конкретного события, для того, чтобы привести UI в новое требуемое состояние, нужно знать и рассматривать все
возможные текущие состояния графа объектов в каждый момент времени. Это можно моделировать стэйт-машиной, но если количество состояний и переходов
достаточно велико, это становится комбинаторным взрывом и невозможной когнитивной нагрузкой для разработчика.

The new Hope.
компания Facebook в 2013 году зарелизила библиотеку React, и это изменило способ думать об архитектуре реактивного инерфейса.
В предположении, что состояние UI выводится из состояния информационной модели приложения, можно писать UI в терминах простых чистых функций,
которые принимают на вход данные и возвращают тоже данные. Теперь не надо обновлять состояние интерфейса, нужно только обновлять состояние своего приложения,
но это не является Incidental Complexity, а доменная сложность. Это-то нам все равно придется делать.
Казалось бы, вот решение всех наших проблем со сложностью, но...

На любом языке. Под любую платформу.

Нам предлагается писать приложение на JS, запускаться на JSCore под Android и iOS. Есть попытки реализовать поддержку других платформ, но
реализация React Native для конкретной платформы не является такой уж тривиальной задачей, потому что связано с написанием бриджа
всего API платформы в JS! А потом требуется еще и написать примтивные компоненты на JS, реализовав требуемый интерфейс. Пальцы в кровь.
Тем более что кросс-платформенности это все равно не дает. И трэйдофф между отдельными приложениями под каждую платформу, но с полной пддержкой тулингом и
общим кодом на JS со специальными компонентами под каждую платформу уже не кажется таким очевидным.

Что если мы можем лучше?


2. Minimal techno. Минимальная реализация реконсайла.

- Все апдэйты дерева представлены чистыми данными и асинхронные
- Lingua Franca для всех платформ это данные
- Реализация помещается на листе A4.

=>

- Проблема произведения количества языков программирования на количество платформ сводится к их сумме!
- Реализации платформенных компонентов можно шарить между всеми языками бесплатно
- Реализация reconcile портируется на любой язык за день
- Simple

3. State:
Компоненты можно представить в виде процессов (редукций пропсов)
=> Компонент это трансдьюсер.
Через это реализуются все потребность lifecycle
- Кэширование и оптимизация

4. Давайте пойдем дальше.
Разворачивание компонентов это в буквальном смысле подстановка.
Очень напоминает бета-редукцию. А не Лисп ли перед нами?

Десятое Правило Greenspun

=> например, переписав его в CPS мы можем получить то, о чем так долго говорили большевики, т.е. Fiber
Но за пределами однопоточного мира это опционально. Там, где есть трэды, файбер не нужен.

- Проблема

Нам не нужен одинаковый код интерфейса под все платформы. Нам нужна поддержка всех платформ и по-скорее, с
лэйаутом сами разберемся и CSS нам тоже не особо нужен. Хотим оставить код платформ небольшим, но получить
сразу все компоненты. Мы хотим получить это не за так, а за описание конфигурации лэйаута под нужные платформы на стороне приложения
Т.е. таким образом мы останемся ближе к мэйнстриму, и API вендоров.
Там, за стеной, на стороне нашего хоста находится не дерево DOM как бы нам этого ни хотелось.
Там находится произвольные граф объектов. Для описания которого нам пока не хватает языка и структура данных component не очень годится

Что если реконсайлить можно не только деревья?

Давайте рассмотрим пример задачи:

    [[NSLayoutConstraint constraintWithItem:view1
                                  attribute:NSLayoutAttributeWidth
                                  relatedBy:NSLayoutRelationEqual
                                     toItem:view2
                                  attribute:NSLayoutAttributeWidth
                                 multiplier:1
                                   constant:0] setActive:YES];

Мы видим объект, не включенный в дерево NSView, который связывает две другие вьюшки

Чтобы такой объект описать в нашем языке не хватает возможности ссылаться на компоненты
Все что мы пока можем делать, это добавлять их в дерево, возвращая элементы из рендер-функции
элемент - суть описание конструирования этого объекта, не ссылки на него
Это как если бы в нашем языке не было переменных:
Нельзя написать
var x = new View("view1");
new Constraint(x);
new View("view2").addSubview(x);

Один и тот же объект не может быть зареферен дважды!

Давайте вернемся к интерпретатору. Что в лиспе отвечает понятию переменной, имеющей некоторое значение?

Это тот самый env! который мы давно потеряли

env в интерпретаторе лиспа таскается за собой практически без изменений. И пополняется только в одном месте.
каком?

Правильно! в правиле аппликации лямбды! Таким образом нам не хватает всего одной вещи:

['apply (fn [x]
            [some-component x])
   [container 1]]

Лямбды мы можем реализовать в терминах хостовых лямбд! Нам нужно только кастомное правило их применения, чтобы
у нас был шанс зареконсайлить компоненты, которые соответствуют элементам-параметрам

Вы спросите, а как же теперь объявить переменную-то!
ну let это макрос


  (def my-label
    (render
      (fn [x]
         {:noria/type :text
          :noria/props {:text (str x)}})))

  (def my-lambda
    (render
     (fn []
       ['apply (fn [x]
                 {:noria/type :box
                  :noria/props {:child x}})
        [my-label 12]])))

Теперь можно ссылаться на компоненты

(lete [x [my-component "c1"]
       y [my-component "c2"]]

  [{:noria/type :NSLayoutConstraint
    :nslayout/from x
    :nslayout/to y
    :nslayout/relation :=
    :nslayout/active true}
    {:noria/type :NSView
     :noria/children [x y]}])

Не хватает еще eval-а векторов, но это мелочи

Можно желаемого добиться и другими способами:
- tempid

[^{:noria/tempid :my-view1} [my-component "view1"]
 ^{:noria/tempid :my-view2} [my-component "view2"]
  {:noria/type :NSLayoutConstraint
   :noria/from (tempid :my-view1)
   :noria/to (tempid :my-view2)}]

- Грязный reconcile!: (грязный потому что, ему придется сайд-эффектить в компонент, который еще даже не построен, ну или как вариант в
трэд-биндинг)

(let [x (reconcile! [my-component "view1"])]
...)

Кроме того дерево компонентов перестает быть деревом и превращается в граф.
В графе каждая вершина обязана обзавестись identity, то есть наши компоненты должны иметь айдишки:

{:components {component-id {:noria/subst component-id2}
              component-id2 {...}}}
